<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=iso-8859-1">
		<title>SPI</title>
                <link rel="stylesheet" href="../../main.css">
		<style type="text/css" media="screen"><!--
td { border: solid 1px #808080 }
--></style>
	</head>

	<body class="content_page">
		<div align="center" class="heading">
			
			The Serial Peripheral Interface (SPI)
</div>
		<div class="content">
			<div align="center">
				<p>[Overview] [<a href="#spi_decription">Bus Description</a>] [<a href="#spi_regs">Registers</a>] [<a href="#spi_isp">ISP</a>]</p>
			</div>
		</div>
		<div class="heading_small">
			<div class="content">
				<p>Overview</p>
			</div>
		</div>
		<div class="content">
			<p>The SPI (Serial Peripheral Interface) is a peripheral used to communicate between the AVR and other devices, like others AVRs, external EEPROMs, DACs, ADCs, etc. With this interface, you have one Master device which initiates and controls the communication, and one or more slaves who receive and transmit to the Master.</p>
			<p>The core of the SPI is an 8-bit shift register in both the Master and the Slave, and a clock signal generated by the Master. Let's say the Master wants to send a byte of data (call it A) to the Slave and at the same time receive another byte of data from the Slave (call it B). Before starting the communication, the Master places A in its shift register, and the Slave places B in its shift register. (Figure 1-a). Then the Master generates 8 clock pulses, and the contents of the Master's shift register are transferred to the Slave's shift register and vice versa (Figure 1-b to 1-e). So, at the end of the clock pulses, the Master has completely received B, and the Slave has received A. As you can see, the transmission and reception occurs at the same time, so it is a full duplex data transfer.</p>
			<p>The first image is the sate of the two devices before the transfer:</p>
			<img src="../img/spi_fig1_a.gif" border="0" alt="" class="image"><br>
			<img src="../img/spi_fig1_b.gif" border="0" alt="" class="image"><br>
			<img src="../img/spi_fig1_c.gif" border="0" alt="" class="image"><br>
			<img src="../img/spi_fig1_d.gif" border="0" alt="" class="image"><br>
			<img src="../img/spi_fig1_e.gif" border="0" alt="" class="image"><br>
		</div>
		<div class="heading_small">
			<div class="content">
				<p>Bus Description<a name="spi_decription"></a></p>
			</div>
		</div>
		<div class="content">
			<p>Before you can successfully communicate through the SPI, both the Master and Slave must agree on some clock signal settings. Details on how to configure this in the AVR will be discussed later.</p>
			<p>Please note that not all AVRs have an SPI (you must check the particular datasheet). If your AVR doesn't have an SPI, you still can implement it in software (the details are not discussed here).</p>
			<p>In an AVR, four signals (pins) are used for the SPI: MISO, MOSI, SCK and SS' (SS' means SS complemented). Here is a brief description of the function of each signal:</p>
			<p>MISO (Master In Slave Out): the input of the Master's shift register, and the output of the Slave's shift register.</p>
			<p>MOSI (Master Out Slave In): the output of the Master's shift register, and the input of the Slave's shift register.</p>
			<p>SCK (Serial Clock): In the Master, this is the output of the clock generator. In the Slave, it is the input clock signal.</p>
			<p>SS' (Slave Select): Since in an SPI setup you can have several slaves at the same time, you need a way to select which Slave you want to communicate to. This is what SS' is used for. If SS' is held in a high state, all Slave SPI pins are normal inputs, and will not receive incoming SPI data. On the other hand, if SS' is held in a low state, the SPI is activated. The software of the Master must control the SS'-line of each Slave.<br>
				If the SPI-device is configured as a Master, the behavior of the SS' pin depends on the configured data direction of the pin. If SS' is configured as an output, the pin does not affect the SPI. If SS' is configured as an input, it must be held high to ensure Master SPI operation. If the SS' pin is driven low, the SPI system interprets this as another Master selecting the SPI as a Slave and starting to send data to it. Having two SPI Masters is quite unusual, so the details of how to manage this are not discussed here (if you are curious, read the datasheet). So, if you want to keep your life simple, configure the Master's SS' pin as an output.</p>
			<p>The following figures show a typical setup used with SPI:</p>
			<img src="../img/spi_Figure2_a.gif" alt="" height="199" width="255" border="0"><br>
			<img src="../img/spi_Figure2_b.gif" alt="" height="352" width="255" border="0">
			<p>A word of caution about the SPI pin names. MISO, MOSI, SCK and SS' are the names used by AVRs. Other devices may use a different set of names. You must check the data sheet of the particular device you are using to get them right.</p>
			<p>What are the data directions of the SPI pins? It depends on the particular pin and on whether the SPI is set as a Master or Slave. In general, there are two possibilities. A pin is configured as an input regardless of the setting of the Data Direction Register of the port, or the pin must be configured by the user according to its function. The following table summarizes this:</p>
			<table border="1" cellspacing="0" cellpadding="0" class="content">
				<tr>
					<th>Pin</th>
					<th>Direction, Master SPI</th>
					<th>Direction, Slave SPI</th>
				</tr>
				<tr>
					<td>MOSI</td>
					<td>User defined</td>
					<td>Input</td>
				</tr>
				<tr>
					<td>MISO</td>
					<td>Input</td>
					<td>User defined</td>
				</tr>
				<tr>
					<td>SCK</td>
					<td>User defined</td>
					<td>Input</td>
				</tr>
				<tr>
					<td>SS'</td>
					<td>User defined</td>
					<td>Input</td>
				</tr>
			</table>
			<div class="heading_small">
				<p>Registers<a name="spi_regs"></a></p>
			</div>
			<p>[SPCR] [<a href="#spsr">SPSR</a>] [<a href="#spdr">SPDR</a>]</p>
			<p class="heading_small">SPCR</p>
			<p>(SPI Control Register)</p>
			<table border="1" cellspacing="0" cellpadding="0">
				<tr>
					<th width="40">Bit 7</th>
					<th width="40">Bit 6</th>
					<th width="40">Bit 5</th>
					<th width="40">Bit 4</th>
					<th width="40">Bit 3</th>
					<th width="40">Bit 2</th>
					<th width="40">Bit 1</th>
					<th width="40">Bit 0</th>
				</tr>
				<tr>
					<td width="40">
						<div align="center">
							SPIE</div>
					</td>
					<td width="40">
						<div align="center">
							SPE</div>
					</td>
					<td width="40">
						<div align="center">
							DORD</div>
					</td>
					<td width="40">
						<div align="center">
							MSTR</div>
					</td>
					<td width="40">
						<div align="center">
							CPOL</div>
					</td>
					<td width="40">
						<div align="center">
							CPHA</div>
					</td>
					<td width="40">
						<div align="center">
							SPR1</div>
					</td>
					<td width="40">
						<div align="center">
							SPR0</div>
					</td>
				</tr>
			</table>
			<p>SPIE (SPI Interrupt Enable) bit: Set SPIE to one if you want the SPI interrupt to be executed when a serial transfer is completed.</p>
			<p>SPE (SPI Enable) bit: If you want to use the SPI, you must set this bit.</p>
			<p>DORD (Data Order) bit: You can choose in which order the data will be transmitted. Set DORD to one to send the least significant bit (LSB) first. Set DORD to zero to send the most significant bit (MSB) first.</p>
			<p>MSTR (Master/Slave Select) bit: Set MSTR to configure the AVR as a Master SPI device. Clear MSTR to configure it as a Slave.</p>
			<p>CPOL (Clock Polarity) and CPHA (Clock Phase) bits: As stated previously, Master and Slave must agree on how to interpret the clock signal. The first thing to do is to configure which logic level the clock will be in when the SPI is idle. If CPOL is set to one, SCK is high when idle, and if CPOL is set to zero, SCK is low when idle. The second thing is to configure during which clock transition the data will be sampled. Set CPHA to sample the data on the trailing (last) edge, and clear CPHA to sample the data in the leading (first) edge.</p>
			<p>So, there are four different ways of configuring the clock generation, which are known as 'SPI modes'. The following table summarizes the four SPI modes.</p>
			<table border="1" cellspacing="0" cellpadding="0" class="content">
				<tr>
					<th>SPI Mode</th>
					<th>CPOL</th>
					<th>CPHA</th>
					<th>Sample</th>
				</tr>
				<tr>
					<td>0</td>
					<td>0</td>
					<td>0</td>
					<td>Leading (Rising) Edge</td>
				</tr>
				<tr>
					<td>1</td>
					<td>0</td>
					<td>1</td>
					<td>Trailing (Falling) Edge</td>
				</tr>
				<tr>
					<td>2</td>
					<td>1</td>
					<td>0</td>
					<td>Leading (Falling) Edge</td>
				</tr>
				<tr>
					<td>3</td>
					<td>1</td>
					<td>1</td>
					<td>Trailing (Rising) Edge</td>
				</tr>
			</table>
			<p>The following image shows figure 76 and 77 from the mega128 datasheet:</p>
			<p><img src="../img/spi_formats.gif" alt="" height="507" width="501" border="0"></p>
			<p>SPR1 and SPR2 (SPI Clock Rate Select) bits: The SPR bits configure the frequency of the clock signal. Since the Slave reads the clock from an input pin, the SPR bits have no effect on the Slave. The frequency of the SPI clock is related to the frequency of the AVR oscillator. The faster the SPI clock signal is, the faster the data trasfer will be, however, you must respect the maximum clock frequency specified by the Slave (as usual, read the datasheet). The following table summarizes the relationship between the SCK frequency and the SPR bits:</p>
			<table border="1" cellspacing="0" cellpadding="0" class="content">
				<tr>
					<th>SPR1</th>
					<th>SPR0</th>
					<th>SCK frequency</th>
				</tr>
				<tr>
					<td>0</td>
					<td>0</td>
					<td>fosc/4</td>
				</tr>
				<tr>
					<td>0</td>
					<td>1</td>
					<td>fosc/16</td>
				</tr>
				<tr>
					<td>1</td>
					<td>0</td>
					<td>fosc/64</td>
				</tr>
				<tr>
					<td>1</td>
					<td>1</td>
					<td>fosc/128</td>
				</tr>
			</table>
			<p class="heading_small">SPSR<a name="spsr"></a></p>
			<p>(SPI Status Register)</p>
			<table border="1" cellspacing="0" cellpadding="0">
				<tr>
					<th width="40">Bit 7</th>
					<th width="40">Bit 6</th>
					<th width="40">Bit 5</th>
					<th width="40">Bit 4</th>
					<th width="40">Bit 3</th>
					<th width="40">Bit 2</th>
					<th width="40">Bit 1</th>
					<th width="45">Bit 0</th>
				</tr>
				<tr>
					<td width="40">
						<div align="center">
							SPIF</div>
					</td>
					<td width="40">
						<div align="center">
							WCOL</div>
					</td>
					<td width="40">
						<div align="center">
							---</div>
					</td>
					<td width="40">
						<div align="center">
							---</div>
					</td>
					<td width="40">
						<div align="center">
							---</div>
					</td>
					<td width="40">
						<div align="center">
							---</div>
					</td>
					<td width="40">
						<div align="center">
							---</div>
					</td>
					<td width="45">
						<div align="center">
							(SPI2x)</div>
					</td>
				</tr>
			</table>
			<p>SPIF (SPI Interrupt Flag) bit: This is a read only bit. It is set by hardware when a serial transfer is complete. SPIF is cleared by hardware when the SPI interrupt handling vector is executed, or when the SPIF bit and the SPDR register are read.</p>
			<p>WCOL (Write Colision Flag) bit: This is a read only bit. The WCOL bit is set if the SPDR register is written to during a data transfer. The WCOL bit (and the SPIF bit) are cleared by first reading the SPI Status Register with WCOL set, and then accessing the SPI Data Register.</p>
			<p>SPI2x (Double SPI Speed) bit: This feature is not implemented in all AVRs (check the particular data sheet). When this bit is set to one, the SPI speed will be doubled when the SPI is in Master mode.</p>
			<p class="heading_small">SPDR<a name="spdr"></a></p>
			<p>(SPI Data Register)</p>
			<p>The SPI Data Register is a read/write register used for data transfer between the Register File and the SPI Shift Register. Writing to the register initiates data transmission. Reading the register causes the Shift Register receive buffer to be read.</p>
			<p>Finally, here is a code snippet to generate a data transfer between a Master and a Slave. Both Master and Slave are configured to send the MSB first and to use SPI mode 3. The clock frequency of the Master is fosc/16. The Master will send the data 0xAA, and the Slave the data 0x55.</p>
			<p>Master code:</p>
			<table width="95%" border="0" cellspacing="0" cellpadding="0" class="codebox">
				<tr>
					<td width="150" style="border-width: 0px;" valign="top"><nobr>SPI_Init:<br>
							sbi DDRB,DDB5<br>
							sbi DDRB,DDB7<br>
							sbi DDRB,DDB4<br>
							ldi r16,01011101b<br>
							out SPCR,r16<br>
							&nbsp;<br>
							SPI_Send:<br>
							ldi r16,0xAA<br>
							out SPDR,r16<br>
							Wait:<br>
							sbis SPSR,SPIF<br>
							rjmp Wait<br>
							in SPDR,r16 </nobr></td>
					<td style="border-width: 0px;" valign="top"><nobr>&nbsp;<br>
							; Set MOSI as output.<br>
							; Set SCK as output.<br>
							; Set SS' as output.<br>
							; Set SPI as a Master, with interrupt disabled,<br>
							; MSB first, SPI mode 3 and clock frequency fosc/16.<br>
							&nbsp;<br>
							&nbsp;<br>
							&nbsp;<br>
							; Initiate data transfer.<br>
							&nbsp;<br>
							; Wait for transmission to complete.<br>
							&nbsp;<br>
							; The received data is placed in r16. </nobr></td>
				</tr>
			</table>
			<p>Slave code</p>
			<table width="95%" border="0" cellspacing="0" cellpadding="0" class="codebox">
				<tr>
					<td width="150" style="border-width: 0px;" valign="top"><nobr>SPI_Init:<br>
							sbi DDRB,DDB6<br>
							ldi r16,01001100b<br>
							out SPCR,r16<br>
							ldi r16,0x55<br>
							out SPDR,r16<br>
							&nbsp;<br>
							&nbsp;<br>
							SPI_Receive:<br>
							sbis SPSR,SPIF<br>
							rjmp SPI_Receive<br>
							in r16,SPDR </nobr></td>
					<td style="border-width: 0px;" valign="top"><nobr>&nbsp;<br>
							; Set MISO as an output.<br>
							; Set SPI as a Slave, with interrupt disabled,<br>
							; MSB first and SPI mode 3.<br>
							&nbsp;<br>
							; Send 0x55 on Master request.<br>
							&nbsp;<br>
							&nbsp;<br>
							&nbsp;<br>
							&nbsp;<br>
							; Wait for reception to complete.<br>
							; The received data is placed in r16. </nobr></td>
				</tr>
			</table>
			<p class="heading_small">SPI and In Circuit Programming (ISP)<a name="spi_isp"></a></p>
			<p>The SPI interface is also used to program the AVR. If you want to program your AVR in-circuit and are using the SPI interface, a series resistor should be placed on each of the three dedicated lines to avoid 'driver contention' (see figure below). A driver contention is the situation you get if two outputs are connected together. For more details, see AVR application note No. 910.</p>
			<img src="../img/spi_Figure3.gif" border="0" alt="" class="image"></div>
	</body>
</html>

